===== DUMP: All .c source files =====

---------- main.c ----------
#include <stdlib.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>

#include "modes/modes.h"
#include "key_iv/key_iv.h"
#include "des_block/subkey_genaration/subKeyGen.h"

#include <inttypes.h>

void testFileEncryption(uint64_t key);
void testStringEncryption(uint64_t key);
void testBlockEncryption(uint64_t key);

int main() {

    // uint64_t key = 0x133457799BBCDFF1;

    testFileEncryption(generate_random_key());

    return 0;
}

void testFileEncryption(uint64_t key)
{
    printf("encrypting...\n");

    des_PCBC_encrypt_file("../test/plaintext.txt","../test/ciphertext.txt",key);

    printf("decrypting...\n");

    des_PCBC_decrypt_file("../test/ciphertext.txt","../test/decoded.txt",key);
}

void testStringEncryption(uint64_t key)
{
    const char *plaintext = "DES DES 123";
    char encrypted[64] = {0};
    char decrypted[64] = {0};

    printf("Plaintext: %s\n", plaintext);

    int newLen = des_PCBC_encrypt_string(plaintext, encrypted, key);

    printf("encrypted: ");

    fwrite(encrypted,sizeof(char),newLen,stdout);

    des_PCBC_decrypt_string(encrypted, decrypted, newLen, key);

    printf("\nDecrypted: %s\n", decrypted);
}

void testBlockEncryption(uint64_t key)
{
    uint64_t subKeys[16];
    generate_sub_keys(key, subKeys);

    uint64_t block = 0xAABBCCDD11223344;

    uint64_t cipherBlock = des_block(block, subKeys, ENCRYPT);

    uint64_t decoded = des_block(cipherBlock, subKeys, DECRYPT);

    printf("Plaintext:  0x%016" PRIx64 "\n", block);
    printf("Ciphertext: 0x%016" PRIx64 "\n", cipherBlock);
    printf("decoded: 0x%016" PRIx64 "\n", decoded);

    
}.
---------- f.c ----------
#include <stdint.h>
#include <stdlib.h>
#include "f.h"
extern const int E[48];
extern const char S[8][4][16];
extern const int P[32];

uint64_t expand(uint32_t right);
uint32_t keyed_substitution(uint64_t right);
uint32_t PBox_transposition(uint32_t right);

uint32_t F(uint32_t right,uint64_t subKey)
{
    // implamenting the mangler function

    uint32_t res;

    uint64_t expandedRight = expand(right);

    expandedRight ^= subKey;

    res = keyed_substitution(expandedRight);

    res = PBox_transposition(res);

    return res;
}

uint64_t expand(uint32_t right)
{
    int expandedSize = 48;
    uint64_t result = 0;

    for (int i = 0; i < expandedSize; i++) {
        int bitIndex = E[i] - 1; 
        int bit = (right >> (SIZE_OF_HALF_BLOCK_BITS - 1 - bitIndex)) & 1; 
        result |= ((uint64_t)bit << (expandedSize - 1 - i)); 
    }

    return result;
}

uint32_t keyed_substitution(uint64_t right)
{
    uint32_t res = 0;

    for (int i = 0; i < 8; i++) {
        // Extract the i-th 6-bit chunk 
        // with the mask 0011 1111 (last 6 bits)
        uint8_t chunk = (right >> (42 - 6 * i)) & 0x3F;

        // Compute row
        // getting bit 6 and moving it to place 2 
        //than connecting with 1
        int row = ((chunk & 0x20) >> 4) | (chunk & 0x01);  

        //compute col 
        // bits 2–5
        int col = (chunk >> 1) & 0x0F;                     

        // Lookup S-box output (4 bits)
        uint8_t s_out = S[i][row][col] & 0x0F;

        // Place into result (MSB-first)
        res |= s_out << (28 - 4 * i);
    }

    return res;
}

uint32_t PBox_transposition(uint32_t right)
{
    uint32_t res = 0;
    
    for (int i = 0; i < SIZE_OF_HALF_BLOCK_BITS; i++)
    {
        //fetch the next bit according to the P box
        int bit = (right >> (SIZE_OF_HALF_BLOCK_BITS - P[i])) & 1;

        //place it
        res |= (bit << (SIZE_OF_HALF_BLOCK_BITS - 1 - i));
    }

    return res;
    
}.
---------- des.c ----------
#include <stdlib.h>
#include <stdint.h>
#include "des.h"


uint64_t permute(uint64_t block, const int table[64])
{
    uint64_t res = 0;

    for (int i = 0; i < SIZE_OF_BLOCK_BITS; i++)
    {
        int bit = (block >> (SIZE_OF_BLOCK_BITS - table[i])) & 1;
        res |= ((uint64_t)bit << (SIZE_OF_BLOCK_BITS - 1 - i));
    }

    return res;
}

uint64_t des_block(uint64_t block, uint64_t subkeys[], Operation operation)
{
    block = permute(block, IP);

    uint32_t R = block & L64_MASK;
    uint32_t L = (block & H64_MASK) >> SIZE_OF_HALF_BLOCK_BITS;
    uint32_t RCopy;
    int subKeyIndex;

    for (int i = 0; i < NUM_ROUNDS; i++)
    {
        subKeyIndex = (operation == ENCRYPT) ? i : NUM_ROUNDS - 1 - i;

        RCopy = R;

        R = F(R, subkeys[subKeyIndex]) ^ L;

        L = RCopy;
    }

    block = ((uint64_t)R << SIZE_OF_HALF_BLOCK_BITS) | L;

    return permute(block, PI);
}
.
---------- subKeyGen.c ----------
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "subKeyGen.h"

extern const int PC1[SIZE_OF_EFFECTIVE_KEY_BITS];
extern const int PC2[SIZE_OF_SUBKEY_BITS];
extern const int LEFT_SHIFTS[NUM_OF_SUBKEYS];

uint64_t permuted_choice2(uint32_t Ci, uint32_t Di);

typedef struct subKeyGenType
{
    uint32_t Ci; // 28-bit
    uint32_t Di; // 28-bit
    int i;
} subKeyGen;

uint32_t circular_left_shift_28(uint32_t chunk, int nshifts)
{
    chunk &= LAST_48_BITS_MASK;
    return ((chunk << nshifts) | (chunk >> (SIZE_OF_HALF_KEY_BITS - nshifts))) & LAST_48_BITS_MASK;
}

void permuted_choice1(uint64_t key, uint32_t *Ci, uint32_t *Di)
{
    *Ci = 0;
    *Di = 0;

    for (int i = 0; i < SIZE_OF_HALF_KEY_BITS; i++)
    {
        int bit = (key >> (SIZE_OF_BLOCK_BITS - PC1[i])) & 1;
        *Ci |= (bit << (SIZE_OF_HALF_KEY_BITS - 1 - i));
    }

    for (int i = 0; i < SIZE_OF_HALF_KEY_BITS; i++)
    {
        int bit = (key >> (SIZE_OF_BLOCK_BITS - PC1[i + SIZE_OF_HALF_KEY_BITS])) & 1;
        *Di |= (bit << (SIZE_OF_HALF_KEY_BITS - 1 - i));
    }
}

uint64_t permuted_choice2(uint32_t Ci, uint32_t Di)
{
    uint64_t CD = (((uint64_t)Ci) << SIZE_OF_HALF_KEY_BITS) | (Di & LAST_48_BITS_MASK); // combine into 56-bit
    uint64_t subkey = 0;

    for (int i = 0; i < LAST_48_BITS_MASK; i++)
    {
        int bit = (CD >> (SIZE_OF_EFFECTIVE_KEY_BITS - PC2[i])) & 1;
        subkey |= ((uint64_t)bit << ( - i));
    }

    return subkey;
}

void keyGen_init(subKeyGen *skg, uint64_t key)
{
    permuted_choice1(key, &skg->Ci, &skg->Di);

    skg->i = 0;
}

uint64_t keyGen_next(subKeyGen *skg)
{
    // shift the two halfs
    skg->Ci = circular_left_shift_28(skg->Ci, LEFT_SHIFTS[skg->i]);
    skg->Di = circular_left_shift_28(skg->Di, LEFT_SHIFTS[skg->i]);

    // incrament i
    skg->i++;

    // return the permuted Choice 2
    return permuted_choice2(skg->Ci, skg->Di);
}

void generate_sub_keys_plain(uint64_t key, uint64_t subkeys[NUM_OF_SUBKEYS])
{
    subKeyGen skg;
    keyGen_init(&skg, key);

    for (int i = 0; i < NUM_OF_SUBKEYS; i++)
    {
        subkeys[i] = keyGen_next(&skg);
    }
}

// Simple hash to determine child relation
int hash(uint64_t a, uint64_t b)
{
    return ((a % 7) == (b % 13)) ? 0 : 1;
}

void init_graph(uint64_t subkeys[NUM_OF_SUBKEYS],nodePtr nodes_out[NUM_OF_SUBKEYS])
{
    for (int i = 0; i < NUM_OF_SUBKEYS; i++)
    {
        nodes_out[i] = (nodePtr)malloc(sizeof(node));
        if (!nodes_out[i])
        {
            perror("Failed to allocate node");
            for (int k = 0; k < i; k++)
                free(nodes_out[k]);
            
            exit(-1);
        }

        nodes_out[i]->val = subkeys[i];
        nodes_out[i]->children = NULL;
        nodes_out[i]->numChildren = 0;
    }
}

void free_graph(nodePtr subkey_nodes[NUM_OF_SUBKEYS])
{
    for (int i = 0; i < NUM_OF_SUBKEYS; i++)
    {
        free(subkey_nodes[i]->children);
        free(subkey_nodes[i]);
    }
}
 
// generate dag graph based on the keys
// returns 1 if the dag was created and allocated properly
// else 0;
void generate_graph(uint64_t subkeys[NUM_OF_SUBKEYS], nodePtr nodes_out[NUM_OF_SUBKEYS])
{   
    init_graph(subkeys,nodes_out);

    int childCounts[NUM_OF_SUBKEYS] = {0};

    for (int i = 0; i < NUM_OF_SUBKEYS; i++)
    {
        for (int j = 0; j < NUM_OF_SUBKEYS; j++)
        {
            if (hash(subkeys[i], subkeys[j]) == 0)
            {
                childCounts[i]++;
            }
        }
    }

    for (int i = 0; i < NUM_OF_SUBKEYS; i++)
    {
        if (childCounts[i] > 0)
        {
            nodes_out[i]->children = (nodePtr *)malloc(sizeof(nodePtr) * childCounts[i]);
            if (!nodes_out[i]->children)
            {
                perror("Failed to allocate children array");
                for (int k = 0; k <= i; k++)
                {
                    free(nodes_out[k]->children);
                    free(nodes_out[k]);
                }

                exit(-1);
            }
        }
    }

    int fillIndex[NUM_OF_SUBKEYS] = {0};
    for (int i = 0; i < NUM_OF_SUBKEYS - 1; i++)
    {
        for (int j = i + 1; j < NUM_OF_SUBKEYS; j++)
        {
            if (hash(subkeys[i], subkeys[j]) == 0)
            {
                nodes_out[i]->children[fillIndex[i]++] = nodes_out[j];
                nodes_out[i]->numChildren++;
            }
        }
    }
}

uint64_t sum_children_values(nodePtr current_node)
{
    uint64_t sum = 0;
    for (int i = 0; i < current_node->numChildren; i++)
    {
        sum += current_node->children[i]->val;
    }
    return sum;
}

void defuse_subkeys(uint64_t subkeys_output[NUM_OF_SUBKEYS], nodePtr nodes_in[NUM_OF_SUBKEYS])
{
    for (int i = 0; i < NUM_OF_SUBKEYS; i++)
    {
        nodePtr current_node = nodes_in[i];

        uint64_t sum_of_children = sum_children_values(current_node);

        subkeys_output[i] = (current_node->val * sum_of_children) & LAST_48_BITS_MASK;
    }
}

void generate_sub_keys(uint64_t key, uint64_t subkeys[NUM_OF_SUBKEYS])
{
    uint64_t plain_subkeys[NUM_OF_SUBKEYS];
    nodePtr subkey_nodes[NUM_OF_SUBKEYS];

    generate_sub_keys_plain(key, plain_subkeys);

    generate_graph(plain_subkeys, subkey_nodes);
   
    defuse_subkeys(subkeys, subkey_nodes);

    free_graph(subkey_nodes);
}
.
---------- key_iv.c ----------
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>

#include "key_iv.h"

uint64_t generate_random_64();

uint64_t generate_random_key()
{
    srand(time(NULL) ^ clock());

    uint64_t key = 0;
    uint8_t currByte;

    for (int i = 0; i < KEY_SIZE_BYTES; i++)
    {
        // first 7 random bits
        currByte = rand() & LAST_7_BITS_MASK;

        // calculating the parity
        uint8_t parity = __builtin_parity(currByte) ? 0 : 1;

        // appending the parity
        currByte = (currByte << 1) | parity;

        // appending the byte
        key |= ((uint64_t)currByte << i * 8);
    }

    return key;
}

uint64_t generate_random_iv()
{
    //random 64 bit number
    srand(time(NULL) ^ clock());

    uint64_t iv = 0;

    for (int i = 0; i < IV_SIZE_BYTES; i++)
    {
        //genarating the next byte
        uint8_t randByte = rand() & LAST_BYTE_MASK;

        //appending it to the iv
        iv |= ((uint64_t)randByte << i*8);
    }

    return iv;
}

uint32_t generate_random_nonce()
{
    //random 32 bit number
    srand(time(NULL) ^ clock());

    uint32_t nonce = 0;

    for (int i = 0; i < NONCE_SIZE_BYTES; i++)
    {
        //genarating the next byte
        uint8_t randByte = rand() & LAST_BYTE_MASK;

        //appending it to the nonce
        nonce |= ((uint32_t)randByte << i*8);
    }

    return nonce;
}

uint64_t generate_random_64()
{
    
}
.
---------- CBC.c ----------
#include "modes.h"

int des_CBC_encrypt_string(const char *str, char *dst, uint64_t key)
{
    uint64_t subKeys[16];
    generate_sub_keys(key, subKeys);

    int len = strlen(str);
    int srcIndex = 0;
    int dstIndex = 0;

    uint64_t encrypted;

    uint64_t prevBlock = generate_random_iv();
    memcpy(dst + dstIndex,&prevBlock ,sizeof(prevBlock));
    dstIndex += IV_SIZE_BYTES;

    int lenOfPrefectBlocks = (len / SIZE_OF_BLOCK_BYTES) * SIZE_OF_BLOCK_BYTES;

    while (srcIndex < lenOfPrefectBlocks)
    {
        uint64_t block;

        memcpy(&block, str + srcIndex, SIZE_OF_BLOCK_BYTES);

        block ^= prevBlock;

        encrypted = des_block(block, subKeys, ENCRYPT);

        prevBlock = encrypted;

        memcpy(dst + dstIndex, &encrypted, SIZE_OF_BLOCK_BYTES);

        dstIndex += SIZE_OF_BLOCK_BYTES;
        srcIndex += SIZE_OF_BLOCK_BYTES;
    }

    uint8_t blockBuffer[8] = {0};

    int numOfTailingBytes = len - lenOfPrefectBlocks;

    // load the tailing bytes into a buffer
    memcpy(blockBuffer, str + srcIndex, numOfTailingBytes);

    // create the last block (with the padding)
    uint64_t lastBlock = add_padding(blockBuffer, numOfTailingBytes);

    lastBlock ^= prevBlock;

    // encrypt te last block
    encrypted = des_block(lastBlock, subKeys, ENCRYPT);

    // add it to the ciphertext
    memcpy(dst + dstIndex, &encrypted, SIZE_OF_BLOCK_BYTES);

    // return the length
    return dstIndex + SIZE_OF_BLOCK_BYTES;
}

void des_CBC_decrypt_string(const char *cipher, char *dst, int length, uint64_t key)
{
    uint64_t subKeys[16];

    generate_sub_keys(key, subKeys);

    int srcIndex = 0;
    int dstIndex = 0;
    
    uint64_t prevBlock;

    memcpy(&prevBlock,cipher + srcIndex,sizeof(prevBlock));
    srcIndex += IV_SIZE_BYTES;

    for (; srcIndex < length; srcIndex += SIZE_OF_BLOCK_BYTES)
    {
        uint64_t block;

        memcpy(&block, cipher + srcIndex, 8);

        uint64_t decrypted = des_block(block, subKeys, DECRYPT);

        decrypted ^= prevBlock;

        prevBlock = block;        

        memcpy(dst + dstIndex, &decrypted, 8);

        dstIndex += SIZE_OF_BLOCK_BYTES;
    }

    uint64_t lastBlock;
    memcpy(&lastBlock, dst + dstIndex - SIZE_OF_BLOCK_BYTES, SIZE_OF_BLOCK_BYTES);

    // getting the actual size of the last block (without padding)
    int padLen = get_padding_len(lastBlock);

    // putting a null terminator at the end of the original plaintext
    int actualLength = dstIndex - padLen; 
    dst[actualLength] = 0;
}

void des_CBC_encrypt_file(const char *src, const char *dst, uint64_t key)
{
    uint64_t subKeys[16];
    generate_sub_keys(key, subKeys);

    FILE *srcP = fopen(src, "rb");
    FILE *dstP = fopen(dst, "wb");

    if (!srcP || !dstP) return;

    uint8_t blockBuffer[8];
    size_t bytesRead;

    uint64_t prevBlock = generate_random_iv();

    //writing the iv
    fwrite(&prevBlock,sizeof(prevBlock),1,dstP);

    while ((bytesRead = fread(blockBuffer, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, srcP)) == SIZE_OF_BLOCK_BYTES)
    {
        uint64_t block;
        memcpy(&block, blockBuffer, SIZE_OF_BLOCK_BYTES);

        //xor-ing with the previus block (or iv for the first round)
        //as instructed for the CBC mode
        block ^= prevBlock;

        uint64_t encrypted = des_block(block, subKeys, ENCRYPT);

        prevBlock = encrypted;

        fwrite(&encrypted, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, dstP);
    }

    // Pad the final block
    uint64_t lastBlock = add_padding(blockBuffer, bytesRead);

    //xor it with prev
    lastBlock ^= prevBlock;

    uint64_t encrypted = des_block(lastBlock, subKeys, ENCRYPT);
    fwrite(&encrypted, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, dstP);
    

    fclose(srcP);
    fclose(dstP);
}

void des_CBC_decrypt_file(const char *cipher, const char *dst, uint64_t key)
{
    uint64_t subKeys[16];
    generate_sub_keys(key, subKeys);

    FILE *cipherP = fopen(cipher, "rb");
    FILE *dstP = fopen(dst, "wb");

    if (!cipherP || !dstP)
        return;

    uint64_t currentBlock, nextBlock;
    uint64_t prevBlock;
    size_t bytesRead;

    //reading the iv
    fread(&prevBlock, sizeof(uint64_t), 1, cipherP);
    
    bytesRead = fread(&currentBlock, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, cipherP);

    while (bytesRead == SIZE_OF_BLOCK_BYTES)
    {
        bytesRead = fread(&nextBlock, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, cipherP);

        uint64_t decrypted = des_block(currentBlock, subKeys, DECRYPT);

        decrypted ^= prevBlock;

        prevBlock = currentBlock;

        int isLast = (bytesRead == 0);

        if (isLast)
        {
            // This is the last block, strip padding
            int padLen = get_padding_len(decrypted);
            fwrite(&decrypted, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES - padLen, dstP);
        }
        else
        {
            fwrite(&decrypted, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, dstP);
        }

        currentBlock = nextBlock;
    }

    fclose(cipherP);
    fclose(dstP);
}.
---------- CFB.c ----------
#include "modes.h"

int des_CFB_encrypt_string(const char *str, char *dst, uint64_t key)
{
    uint64_t subKeys[16];
    generate_sub_keys(key, subKeys);

    int len = strlen(str);
    int srcIndex = 0;
    int dstIndex = 0;

    uint64_t encrypted;
    uint64_t encryptedPrev;

    uint64_t prevBlock = generate_random_iv();
    memcpy(dst + dstIndex,&prevBlock ,sizeof(prevBlock));
    dstIndex += IV_SIZE_BYTES;

    while (srcIndex < len)
    {
        encryptedPrev = des_block(prevBlock,subKeys,ENCRYPT);

        uint64_t block;

        memcpy(&block, str + srcIndex, SIZE_OF_BLOCK_BYTES);

        encrypted = encryptedPrev ^block;
        prevBlock = encrypted;

        memcpy(dst + dstIndex, &encrypted, SIZE_OF_BLOCK_BYTES);

        dstIndex += SIZE_OF_BLOCK_BYTES;
        srcIndex += SIZE_OF_BLOCK_BYTES;
    }

    // add it to the ciphertext
    memcpy(dst + dstIndex, &encrypted, SIZE_OF_BLOCK_BYTES);

    // return the length        
    return dstIndex + SIZE_OF_BLOCK_BYTES;
}

void des_CFB_decrypt_string(const char *cipher, char *dst, int length, uint64_t key)
{
    uint64_t subKeys[16];

    generate_sub_keys(key, subKeys);

    int srcIndex = 0;
    int dstIndex = 0;
    
    uint64_t prevBlock;
    uint64_t encryptedPrev;
    uint64_t decrypted;

    memcpy(&prevBlock,cipher + srcIndex,sizeof(prevBlock));
    srcIndex += IV_SIZE_BYTES;

    for (; srcIndex < length; srcIndex += SIZE_OF_BLOCK_BYTES)
    {
        encryptedPrev = des_block(prevBlock,subKeys,ENCRYPT);

        uint64_t block;

        memcpy(&block, cipher + srcIndex, 8);

        decrypted = encryptedPrev ^ block;
        prevBlock = block;        

        memcpy(dst + dstIndex, &decrypted, 8);

        dstIndex += SIZE_OF_BLOCK_BYTES;
    }

    uint64_t lastBlock;
    memcpy(&lastBlock, dst + dstIndex - SIZE_OF_BLOCK_BYTES, SIZE_OF_BLOCK_BYTES);

    //null tarminating
    dst[dstIndex] = 0;
}

void des_CFB_encrypt_file(const char *src, const char *dst, uint64_t key)
{
    uint64_t subKeys[16];
    generate_sub_keys(key, subKeys);

    FILE *srcP = fopen(src, "rb");
    FILE *dstP = fopen(dst, "wb");

    if (!srcP || !dstP)
        return;

    uint8_t blockBuffer[8] = {0};
    size_t bytesRead;

    uint64_t prevBlock = generate_random_iv();

    // Write IV
    fwrite(&prevBlock, sizeof(prevBlock), 1, dstP);

    while ((bytesRead = fread(blockBuffer, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, srcP)) == SIZE_OF_BLOCK_BYTES)
    {
        uint64_t block;
        memcpy(&block, blockBuffer, SIZE_OF_BLOCK_BYTES);

        uint64_t encryptedPrev = des_block(prevBlock, subKeys, ENCRYPT);
        uint64_t encrypted = encryptedPrev ^ block;

        prevBlock = encrypted;

        fwrite(&encrypted, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, dstP);
    }

    // pad the last block
    uint64_t paddedBlock = add_padding(blockBuffer, bytesRead);
    uint64_t encryptedPrev = des_block(prevBlock, subKeys, ENCRYPT);
    uint64_t encrypted = encryptedPrev ^ paddedBlock;
    fwrite(&encrypted, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, dstP);

    fclose(srcP);
    fclose(dstP);
}

void des_CFB_decrypt_file(const char *cipher, const char *dst, uint64_t key)
{
    uint64_t subKeys[16];
    generate_sub_keys(key, subKeys);

    FILE *cipherP = fopen(cipher, "rb");
    FILE *dstP = fopen(dst, "wb");

    if (!cipherP || !dstP)
        return;

    uint64_t currentBlock, nextBlock;
    uint64_t prevBlock;
    size_t bytesRead;

    // Read IV
    fread(&prevBlock, sizeof(uint64_t), 1, cipherP);

    bytesRead = fread(&currentBlock, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, cipherP);

    while (bytesRead == SIZE_OF_BLOCK_BYTES)
    {
        bytesRead = fread(&nextBlock, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, cipherP);

        uint64_t decryptedPrev = des_block(prevBlock, subKeys, ENCRYPT);
        uint64_t decrypted = decryptedPrev ^ currentBlock;

        prevBlock = currentBlock;

        int isLast = (bytesRead != SIZE_OF_BLOCK_BYTES);

        if (isLast)
        {
            int padLen = get_padding_len(decrypted);
            fwrite(&decrypted, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES - padLen, dstP);
        }
        else
        {
            fwrite(&decrypted, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, dstP);
        }

        currentBlock = nextBlock;
    }

    fclose(cipherP);
    fclose(dstP);
}

.
---------- CTR.c ----------
#include "modes.h"

uint64_t build_input_block(uint32_t nonce, uint32_t counter);

int des_CTR_encrypt_string(const char *str, char *dst, uint64_t key)
{
    uint64_t subKeys[16];
    generate_sub_keys(key, subKeys);

    int len = strlen(str);
    int srcIndex = 0;
    int dstIndex = 0;

    uint64_t encrypted;
    uint64_t encryptedPrev;

    uint32_t nonce = generate_random_nonce();
    uint32_t counter = 0;

    memcpy(dst + dstIndex, &nonce, sizeof(nonce));
    dstIndex += NONCE_SIZE_BYTES;

    while (srcIndex < len)
    {
        encryptedPrev = des_block(build_input_block(nonce, counter++), subKeys, ENCRYPT);

        uint64_t block;

        memcpy(&block, str + srcIndex, SIZE_OF_BLOCK_BYTES);

        encrypted = encryptedPrev ^ block;

        memcpy(dst + dstIndex, &encrypted, SIZE_OF_BLOCK_BYTES);

        dstIndex += SIZE_OF_BLOCK_BYTES;
        srcIndex += SIZE_OF_BLOCK_BYTES;
    }

    // add it to the ciphertext
    memcpy(dst + dstIndex, &encrypted, SIZE_OF_BLOCK_BYTES);

    // return the length
    return dstIndex + SIZE_OF_BLOCK_BYTES;
}

void des_CTR_decrypt_string(const char *cipher, char *dst, int length, uint64_t key)
{
    uint64_t subKeys[16];

    generate_sub_keys(key, subKeys);

    int srcIndex = 0;
    int dstIndex = 0;

    uint64_t prevBlock;
    uint64_t encryptedInput;
    uint64_t decrypted;

    uint32_t nonce;
    memcpy(&nonce, cipher + srcIndex, sizeof(nonce));

    uint32_t counter = 0;
    srcIndex += NONCE_SIZE_BYTES;

    for (; srcIndex < length; srcIndex += SIZE_OF_BLOCK_BYTES)
    {
        encryptedInput = des_block(build_input_block(nonce, counter++), subKeys, ENCRYPT);

        uint64_t block;

        memcpy(&block, cipher + srcIndex, 8);

        decrypted = encryptedInput ^ block;

        memcpy(dst + dstIndex, &decrypted, 8);

        dstIndex += SIZE_OF_BLOCK_BYTES;
    }

    uint64_t lastBlock;
    memcpy(&lastBlock, dst + dstIndex - SIZE_OF_BLOCK_BYTES, SIZE_OF_BLOCK_BYTES);

    // null tarminating
    dst[dstIndex] = 0;
}

void des_CTR_encrypt_file(const char *src, const char *dst, uint64_t key)
{
    uint64_t subKeys[16];
    generate_sub_keys(key, subKeys);

    FILE *srcP = fopen(src, "rb");
    FILE *dstP = fopen(dst, "wb");

    if (!srcP || !dstP)
        return;

    uint8_t blockBuffer[8] = {0};
    int bytesRead;

    uint32_t nonce = generate_random_nonce();

    // Write the nonce to file
    fwrite(&nonce, sizeof(nonce), 1, dstP);

    uint32_t counter = 0;

    while ((bytesRead = fread(blockBuffer, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, srcP)) == SIZE_OF_BLOCK_BYTES)
    {
        uint64_t block;
        memcpy(&block, blockBuffer, SIZE_OF_BLOCK_BYTES);

        uint64_t encryptedInput = des_block(build_input_block(nonce, counter++), subKeys, ENCRYPT);
        uint64_t encrypted = encryptedInput ^ block;

        fwrite(&encrypted, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, dstP);
    }

    // padd the last block
    uint64_t paddedBlock = add_padding(blockBuffer, bytesRead);
    uint64_t encryptedInput = des_block(build_input_block(nonce, counter++), subKeys, ENCRYPT);
    uint64_t encrypted = encryptedInput ^ paddedBlock;
    fwrite(&encrypted, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, dstP);

    fclose(srcP);
    fclose(dstP);
}

void des_CTR_decrypt_file(const char *cipher, const char *dst, uint64_t key)
{
    uint64_t subKeys[16];
    generate_sub_keys(key, subKeys);

    FILE *cipherP = fopen(cipher, "rb");
    FILE *dstP = fopen(dst, "wb");

    if (!cipherP || !dstP)
        return;

    uint64_t currentBlock, nextBlock;
    size_t bytesRead;

    // Read the nonce
    uint32_t nonce;
    fread(&nonce, sizeof(nonce), 1, cipherP);

    uint32_t counter = 0;

    bytesRead = fread(&currentBlock, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, cipherP);

    while (bytesRead == SIZE_OF_BLOCK_BYTES)
    {
        bytesRead = fread(&nextBlock, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, cipherP);

        uint64_t decryptedInput = des_block(build_input_block(nonce, counter++), subKeys, ENCRYPT);
        uint64_t decrypted = decryptedInput ^ currentBlock;

        int isLast = (bytesRead != SIZE_OF_BLOCK_BYTES);

        if (isLast)
        {
            int padLen = get_padding_len(decrypted);
            fwrite(&decrypted, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES - padLen, dstP);
        }
        else
        {
            fwrite(&decrypted, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, dstP);
        }

        currentBlock = nextBlock;
    }

    fclose(cipherP);
    fclose(dstP);
}

uint64_t build_input_block(uint32_t nonce, uint32_t counter)
{
    return ((uint64_t)nonce << 32) | counter;
}.
---------- ECB.c ----------
#include "modes.h"

// encrypting a string in ECB mode
// returning the length of the ciphertext
int des_ECB_encrypt_string(const char *str, char *dst, uint64_t key)
{
    uint64_t subKeys[16];
    generate_sub_keys(key, subKeys);

    int len = strlen(str);
    int i = 0;

    uint64_t encrypted;

    int lenOfPrefectBlocks = (len / SIZE_OF_BLOCK_BYTES) * SIZE_OF_BLOCK_BYTES;

    while (i < lenOfPrefectBlocks)
    {
        uint64_t block;

        memcpy(&block, str + i, SIZE_OF_BLOCK_BYTES);

        encrypted = des_block(block, subKeys, ENCRYPT);

        memcpy(dst + i, &encrypted, SIZE_OF_BLOCK_BYTES);

        i += SIZE_OF_BLOCK_BYTES;
    }

    uint8_t blockBuffer[8] = {0};

    int numOfTailingBytes = len - lenOfPrefectBlocks;

    // load the tailing bytes into a buffer
    memcpy(blockBuffer, str + i, numOfTailingBytes);

    // create the last block (with the padding)
    uint64_t lastBlock = add_padding(blockBuffer, numOfTailingBytes);

    // encrypt te last block
    encrypted = des_block(lastBlock, subKeys, ENCRYPT);

    // add it to the ciphertext
    memcpy(dst + i, &encrypted, SIZE_OF_BLOCK_BYTES);

    // return the length
    return i + SIZE_OF_BLOCK_BYTES;
}

void des_ECB_decrypt_string(const char *cipher, char *dst, int length, uint64_t key)
{
    uint64_t subKeys[16];

    generate_sub_keys(key, subKeys);

    int dstIndex = 0;

    for (int i = 0; i < length; i += SIZE_OF_BLOCK_BYTES)
    {
        uint64_t block;

        memcpy(&block, cipher + i, 8);

        uint64_t decrypted = des_block(block, subKeys, DECRYPT);

        memcpy(dst + dstIndex, &decrypted, 8);

        dstIndex += SIZE_OF_BLOCK_BYTES;
    }

    uint64_t lastBlock;
    memcpy(&lastBlock, dst + dstIndex - SIZE_OF_BLOCK_BYTES, SIZE_OF_BLOCK_BYTES);

    // getting the actual size of the last block (without padding)
    int padLen = get_padding_len(lastBlock);

    // putting a null terminator at the end of the original plaintext
    int actualLength = dstIndex - padLen;
    dst[actualLength] = '\0';
}

void des_ECB_encrypt_file(const char *src, const char *dst, uint64_t key)
{
    uint64_t subKeys[16];
    generate_sub_keys(key, subKeys);

    FILE *srcP = fopen(src, "rb");
    FILE *dstP = fopen(dst, "wb");

    if (!srcP || !dstP)
        return;

    uint8_t blockBuffer[8];
    size_t bytesRead;

    while ((bytesRead = fread(blockBuffer, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, srcP)) == SIZE_OF_BLOCK_BYTES)
    {
        uint64_t block;
        memcpy(&block, blockBuffer, SIZE_OF_BLOCK_BYTES);

        uint64_t encrypted = des_block(block, subKeys, ENCRYPT);
        fwrite(&encrypted, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, dstP);
    }

    // Pad the final block
    uint64_t lastBlock = add_padding(blockBuffer, bytesRead);
    uint64_t encrypted = des_block(lastBlock, subKeys, ENCRYPT);
    fwrite(&encrypted, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, dstP);

    fclose(srcP);
    fclose(dstP);
}

void des_ECB_decrypt_file(const char *cipher, const char *dst, uint64_t key)
{
    uint64_t subKeys[16];
    generate_sub_keys(key, subKeys);

    FILE *cipherP = fopen(cipher, "rb");
    FILE *dstP = fopen(dst, "wb");

    if (!cipherP || !dstP)
        return;

    uint64_t currentBlock, nextBlock;
    size_t bytesRead;

    // Prime the loop
    bytesRead = fread(&currentBlock, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, cipherP);

    while (bytesRead == SIZE_OF_BLOCK_BYTES)
    {
        bytesRead = fread(&nextBlock, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, cipherP);

        uint64_t decrypted = des_block(currentBlock, subKeys, DECRYPT);

        int isLast = (bytesRead == 0);

        if (isLast)
        {
            // This is the last block, strip padding
            int padLen = get_padding_len(decrypted);
            fwrite(&decrypted, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES - padLen, dstP);
        }
        else
        {
            fwrite(&decrypted, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, dstP);
        }

        currentBlock = nextBlock;
    }

    fclose(cipherP);
    fclose(dstP);
}
.
---------- OFB.c ----------
#include "modes.h"

int des_OFB_encrypt_string(const char *str, char *dst, uint64_t key)
{
    uint64_t subKeys[16];
    generate_sub_keys(key, subKeys);

    int len = strlen(str);
    int srcIndex = 0;
    int dstIndex = 0;

    uint64_t encrypted;
    uint64_t encryptedPrev;

    uint64_t prevBlock = generate_random_iv();
    memcpy(dst + dstIndex,&prevBlock ,sizeof(prevBlock));
    dstIndex += IV_SIZE_BYTES;

    while (srcIndex < len)
    {
        encryptedPrev = des_block(prevBlock,subKeys,ENCRYPT);

        uint64_t block;

        memcpy(&block, str + srcIndex, SIZE_OF_BLOCK_BYTES);

        encrypted = encryptedPrev ^block;
        prevBlock = encryptedPrev;

        memcpy(dst + dstIndex, &encrypted, SIZE_OF_BLOCK_BYTES);

        dstIndex += SIZE_OF_BLOCK_BYTES;
        srcIndex += SIZE_OF_BLOCK_BYTES;
    }

    // add it to the ciphertext
    memcpy(dst + dstIndex, &encrypted, SIZE_OF_BLOCK_BYTES);

    // return the length        
    return dstIndex + SIZE_OF_BLOCK_BYTES;
}

void des_OFB_decrypt_string(const char *cipher, char *dst, int length, uint64_t key)
{
    uint64_t subKeys[16];

    generate_sub_keys(key, subKeys);

    int srcIndex = 0;
    int dstIndex = 0;
    
    uint64_t prevBlock;
    uint64_t encryptedPrev;
    uint64_t decrypted;

    memcpy(&prevBlock,cipher + srcIndex,sizeof(prevBlock));
    srcIndex += IV_SIZE_BYTES;

    for (; srcIndex < length; srcIndex += SIZE_OF_BLOCK_BYTES)
    {
        encryptedPrev = des_block(prevBlock,subKeys,ENCRYPT);

        uint64_t block;

        memcpy(&block, cipher + srcIndex, 8);

        decrypted = encryptedPrev ^ block;
        prevBlock = encryptedPrev;        

        memcpy(dst + dstIndex, &decrypted, 8);

        dstIndex += SIZE_OF_BLOCK_BYTES;
    }

    uint64_t lastBlock;
    memcpy(&lastBlock, dst + dstIndex - SIZE_OF_BLOCK_BYTES, SIZE_OF_BLOCK_BYTES);

    //null tarminating
    dst[dstIndex] = 0;
}

void des_OFB_encrypt_file(const char *src, const char *dst, uint64_t key)
{
    uint64_t subKeys[16];
    generate_sub_keys(key, subKeys);

    FILE *srcP = fopen(src, "rb");
    FILE *dstP = fopen(dst, "wb");

    if (!srcP || !dstP)
        return;

    uint8_t blockBuffer[8] = {0};
    size_t bytesRead;

    uint64_t prevBlock = generate_random_iv();

    // Write the IV
    fwrite(&prevBlock, sizeof(prevBlock), 1, dstP);

    while ((bytesRead = fread(blockBuffer, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, srcP)) == SIZE_OF_BLOCK_BYTES)
    {
        uint64_t block;
        memcpy(&block, blockBuffer, SIZE_OF_BLOCK_BYTES);

        uint64_t encryptedPrev = des_block(prevBlock, subKeys, ENCRYPT);
        uint64_t encrypted = encryptedPrev ^ block;

        prevBlock = encryptedPrev;

        fwrite(&encrypted, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, dstP);
    }

    // pad the last block
    uint64_t paddedBlock = add_padding(blockBuffer, bytesRead);
    uint64_t encryptedPrev = des_block(prevBlock, subKeys, ENCRYPT);
    uint64_t encrypted = encryptedPrev ^ paddedBlock;

    fwrite(&encrypted, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, dstP);

    fclose(srcP);
    fclose(dstP);
}

void des_OFB_decrypt_file(const char *cipher, const char *dst, uint64_t key)
{
    uint64_t subKeys[16];
    generate_sub_keys(key, subKeys);

    FILE *cipherP = fopen(cipher, "rb");
    FILE *dstP = fopen(dst, "wb");

    if (!cipherP || !dstP)
        return;

    uint64_t currentBlock, nextBlock;
    uint64_t prevBlock;
    size_t bytesRead;

    // Read the IV
    fread(&prevBlock, sizeof(uint64_t), 1, cipherP);

    bytesRead = fread(&currentBlock, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, cipherP);

    while (bytesRead == SIZE_OF_BLOCK_BYTES)
    {
        bytesRead = fread(&nextBlock, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, cipherP);

        uint64_t decryptedPrev = des_block(prevBlock, subKeys, ENCRYPT);
        uint64_t decrypted = decryptedPrev ^ currentBlock;

        prevBlock = decryptedPrev;

        int isLast = (bytesRead != SIZE_OF_BLOCK_BYTES);

        if (isLast)
        {
            int padLen = get_padding_len(decrypted);
            fwrite(&decrypted, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES - padLen, dstP);
        }
        else
        {
            fwrite(&decrypted, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, dstP);
        }

        currentBlock = nextBlock;
    }

    fclose(cipherP);
    fclose(dstP);
}
.
---------- PCBC.c ----------
#include "modes.h"

int des_PCBC_encrypt_string(const char *str, char *dst, uint64_t key)
{
    uint64_t subKeys[16];
    generate_sub_keys(key, subKeys);

    int len = strlen(str);
    int srcIndex = 0;
    int dstIndex = 0;

    uint64_t encrypted;

    uint64_t prevBlock = generate_random_iv();
    memcpy(dst + dstIndex, &prevBlock, sizeof(prevBlock));
    dstIndex += IV_SIZE_BYTES;

    int lenOfPrefectBlocks = (len / SIZE_OF_BLOCK_BYTES) * SIZE_OF_BLOCK_BYTES;

    while (srcIndex < lenOfPrefectBlocks)
    {
        uint64_t block;

        memcpy(&block, str + srcIndex, SIZE_OF_BLOCK_BYTES);

        encrypted = des_block(block ^ prevBlock, subKeys, ENCRYPT);

        prevBlock = encrypted ^ block;

        memcpy(dst + dstIndex, &encrypted, SIZE_OF_BLOCK_BYTES);

        dstIndex += SIZE_OF_BLOCK_BYTES;
        srcIndex += SIZE_OF_BLOCK_BYTES;
    }

    uint8_t blockBuffer[8] = {0};

    int numOfTailingBytes = len - lenOfPrefectBlocks;

    // load the tailing bytes into a buffer
    memcpy(blockBuffer, str + srcIndex, numOfTailingBytes);

    // create the last block (with the padding)
    uint64_t lastBlock = add_padding(blockBuffer, numOfTailingBytes);

    lastBlock ^= prevBlock;

    // encrypt te last block
    encrypted = des_block(lastBlock, subKeys, ENCRYPT);

    // add it to the ciphertext
    memcpy(dst + dstIndex, &encrypted, SIZE_OF_BLOCK_BYTES);

    // return the length
    return dstIndex + SIZE_OF_BLOCK_BYTES;
}

void des_PCBC_decrypt_string(const char *cipher, char *dst, int length, uint64_t key)
{
    uint64_t subKeys[16];

    generate_sub_keys(key, subKeys);

    int srcIndex = 0;
    int dstIndex = 0;

    uint64_t prevBlock;

    memcpy(&prevBlock, cipher + srcIndex, sizeof(prevBlock));
    srcIndex += IV_SIZE_BYTES;

    for (; srcIndex < length; srcIndex += SIZE_OF_BLOCK_BYTES)
    {
        uint64_t block;

        memcpy(&block, cipher + srcIndex, 8);

        uint64_t decrypted = des_block(block, subKeys, DECRYPT);

        decrypted ^= prevBlock;

        prevBlock = block ^ decrypted;

        memcpy(dst + dstIndex, &decrypted, 8);

        dstIndex += SIZE_OF_BLOCK_BYTES;
    }

    uint64_t lastBlock;
    memcpy(&lastBlock, dst + dstIndex - SIZE_OF_BLOCK_BYTES, SIZE_OF_BLOCK_BYTES);

    // getting the actual size of the last block (without padding)
    int padLen = get_padding_len(lastBlock);

    // putting a null terminator at the end of the original plaintext
    int actualLength = dstIndex - padLen;
    dst[actualLength] = 0;
}

void des_PCBC_encrypt_file(const char *src, const char *dst, uint64_t key)
{
    uint64_t subKeys[16];
    generate_sub_keys(key, subKeys);

    FILE *srcP = fopen(src, "rb");
    FILE *dstP = fopen(dst, "wb");

    if (!srcP || !dstP)
        return;

    uint8_t blockBuffer[8];
    size_t bytesRead;

    uint64_t prevBlock = generate_random_iv();

    // writing the iv
    fwrite(&prevBlock, sizeof(prevBlock), 1, dstP);

    while ((bytesRead = fread(blockBuffer, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, srcP)) == SIZE_OF_BLOCK_BYTES)
    {
        uint64_t block;
        memcpy(&block, blockBuffer, SIZE_OF_BLOCK_BYTES);

        uint64_t encrypted = des_block(block ^ prevBlock, subKeys, ENCRYPT);

        prevBlock = encrypted ^ block;

        fwrite(&encrypted, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, dstP);
    }

    // Pad the final block
    uint64_t lastBlock = add_padding(blockBuffer, bytesRead);

    // xor it with prev
    lastBlock ^= prevBlock;

    uint64_t encrypted = des_block(lastBlock, subKeys, ENCRYPT);
    fwrite(&encrypted, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, dstP);

    fclose(srcP);
    fclose(dstP);
}

void des_PCBC_decrypt_file(const char *cipher, const char *dst, uint64_t key)
{
    uint64_t subKeys[16];
    generate_sub_keys(key, subKeys);

    FILE *cipherP = fopen(cipher, "rb");
    FILE *dstP = fopen(dst, "wb");

    if (!cipherP || !dstP)
        return;

    uint64_t currentBlock, nextBlock;
    uint64_t prevBlock;
    int bytesRead;
    int isLast;

    // reading the iv
    fread(&prevBlock, sizeof(uint64_t), 1, cipherP);

    bytesRead = fread(&currentBlock, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, cipherP);

    while (bytesRead != 0)
    {
        bytesRead = fread(&nextBlock, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, cipherP);

        uint64_t decrypted = des_block(currentBlock, subKeys, DECRYPT);

        decrypted ^= prevBlock;

        prevBlock = currentBlock ^ decrypted;

        isLast = bytesRead == 0;

        if (isLast)
        {
            // This is the last block, strip padding
            int padLen = get_padding_len(decrypted);
            fwrite(&decrypted, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES - padLen, dstP);
        }
        else
        {
            fwrite(&decrypted, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, dstP);
        }

        currentBlock = nextBlock;
    }

    fclose(cipherP);
    fclose(dstP);
}
.
---------- pkcs7.c ----------
#include <stdint.h>
#include "../modes/modes.h"

uint64_t add_padding(uint8_t tailingBytes[],int numOfBytes)
{
    uint8_t bytes[8] = {0};
    uint64_t res;

    memcpy(bytes, tailingBytes, numOfBytes);  

    uint8_t padValue = SIZE_OF_BLOCK_BYTES - numOfBytes;

    for (int i = numOfBytes; i < SIZE_OF_BLOCK_BYTES; i++) {
        bytes[i] = padValue;  
    }

    memcpy(&res, bytes, SIZE_OF_BLOCK_BYTES);

    return res;
}

int get_padding_len(uint64_t block) {
    uint8_t bytes[8];

    memcpy(bytes,&block,SIZE_OF_BLOCK_BYTES);

    return bytes[SIZE_OF_BLOCK_BYTES - 1];  
}
===== DUMP: All .h header files =====

---------- constants.h ----------
#define LB32_MASK 0x00000001
#define LB64_MASK 0x0000000000000001
#define L64_MASK 0x00000000ffffffff
#define H64_MASK 0xffffffff00000000

#define SIZE_OF_BLOCK_BYTES 8
#define SIZE_OF_BLOCK_BITS 64
#define SIZE_OF_HALF_BLOCK_BITS 32

#define SIZE_OF_KEY_BITS 64
#define SIZE_OF_EFFECTIVE_KEY_BITS 56
#define SIZE_OF_HALF_KEY_BITS 28

#define NUM_ROUNDS 16

#define SIZE_OF_SUBKEY_BITS 48
#define NUM_OF_SUBKEYS 16
#define LAST_48_BITS_MASK 0xFFFFFFF.
---------- f.h ----------
#pragma once

#include "../../constants.h"

#include <stdint.h>

static const int E[SIZE_OF_SUBKEY_BITS] = {
    32, 1, 2, 3, 4, 5,
    4, 5, 6, 7, 8, 9,
    8, 9, 10, 11, 12, 13,
    12, 13, 14, 15, 16, 17,
    16, 17, 18, 19, 20, 21,
    20, 21, 22, 23, 24, 25,
    24, 25, 26, 27, 28, 29,
    28, 29, 30, 31, 32, 1};

static const int P[SIZE_OF_HALF_BLOCK_BITS] = {
    16, 7, 20, 21,
    29, 12, 28, 17,
    1, 15, 23, 26,
    5, 18, 31, 10,
    2, 8, 24, 14,
    32, 27, 3, 9,
    19, 13, 30, 6,
    22, 11, 4, 25};

//[box][row][column]
static const char S[8][4][16] = {
    {// S1
     {14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7},
     {0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8},
     {4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0},
     {15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13}},
    {// S2
     {15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10},
     {3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5},
     {0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15},
     {13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9}},
    {// S3
     {10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8},
     {13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1},
     {13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7},
     {1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12}},
    {// S4
     {7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15},
     {13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9},
     {10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4},
     {3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14}},
    {// S5
     {2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9},
     {14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6},
     {4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14},
     {11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3}},
    {// S6
     {12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11},
     {10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8},
     {9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6},
     {4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13}},
    {// S7
     {4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1},
     {13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6},
     {1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2},
     {6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12}},
    {// S8
     {13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7},
     {1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2},
     {7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8},
     {2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11}}};

uint32_t F(uint32_t right, uint64_t subKey);.
---------- des.h ----------
#pragma once

#include "../f_function/f.h"

static const int IP[] = {
    58, 50, 42, 34, 26, 18, 10,  2, 
    60, 52, 44, 36, 28, 20, 12,  4, 
    62, 54, 46, 38, 30, 22, 14,  6, 
    64, 56, 48, 40, 32, 24, 16,  8, 
    57, 49, 41, 33, 25, 17,  9,  1, 
    59, 51, 43, 35, 27, 19, 11,  3, 
    61, 53, 45, 37, 29, 21, 13,  5, 
    63, 55, 47, 39, 31, 23, 15,  7
};

static const int PI[] = {
    40,  8, 48, 16, 56, 24, 64, 32, 
    39,  7, 47, 15, 55, 23, 63, 31, 
    38,  6, 46, 14, 54, 22, 62, 30, 
    37,  5, 45, 13, 53, 21, 61, 29, 
    36,  4, 44, 12, 52, 20, 60, 28, 
    35,  3, 43, 11, 51, 19, 59, 27, 
    34,  2, 42, 10, 50, 18, 58, 26, 
    33,  1, 41,  9, 49, 17, 57, 25
};

typedef enum
{
    ENCRYPT,
    DECRYPT
} Operation;

// typedef enum CipherMode
// {
//     ECB,
//     CBC,
//     CFB,
//     OFB,
//     CTR
// };

uint64_t des_block(uint64_t block, uint64_t subkeys[], Operation operation);
.
---------- subKeyGen.h ----------
#pragma once

#include "../../constants.h"

#include <stdint.h>

// PC-1: 64-bit input key → 56-bit output (C0 and D0)
static const int PC1[56] = {
    57, 49, 41, 33, 25, 17, 9,
    1, 58, 50, 42, 34, 26, 18,
    10, 2, 59, 51, 43, 35, 27,
    19, 11, 3, 60, 52, 44, 36,
    63, 55, 47, 39, 31, 23, 15,
    7, 62, 54, 46, 38, 30, 22,
    14, 6, 61, 53, 45, 37, 29,
    21, 13, 5, 28, 20, 12, 4};

// PC-2: 56-bit C||D → 48-bit subkey
static const int PC2[48] = {
    14, 17, 11, 24, 1, 5,
    3, 28, 15, 6, 21, 10,
    23, 19, 12, 4, 26, 8,
    16, 7, 27, 20, 13, 2,
    41, 52, 31, 37, 47, 55,
    30, 40, 51, 45, 33, 48,
    44, 49, 39, 56, 34, 53,
    46, 42, 50, 36, 29, 32};

static const int LEFT_SHIFTS[16] = {
    1, 1, 2, 2,
    2, 2, 2, 2,
    1, 2, 2, 2,
    2, 2, 2, 1};

//-----------graph related-----------------

typedef struct nodeType
{
    uint64_t val;
    struct nodeType **children;
    int numChildren;
} node, *nodePtr;

// standard DES subkey generation implementation
void generate_sub_keys_plain(uint64_t key, uint64_t subkeys[NUM_OF_SUBKEYS]);
void generate_sub_keys(uint64_t key, uint64_t subkeys[NUM_OF_SUBKEYS]);
.
---------- key_iv.h ----------
#pragma once
#include <stdint.h>

#define KEY_SIZE_BYTES 8
#define IV_SIZE_BYTES 8
#define NONCE_SIZE_BYTES 4
#define LAST_7_BITS_MASK 0x7f
#define LAST_BYTE_MASK 0xff

uint64_t generate_random_key();
uint64_t generate_random_iv();
uint32_t generate_random_nonce();.
---------- modes.h ----------
#pragma once

#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <stdio.h>

#include "../des_block/main_encryption/des.h"
#include "../des_block/subkey_genaration/subKeyGen.h"
#include "../key_iv/key_iv.h"
#include "../pkcs7_padding/pkcs7.h"

#include "inttypes.h"

// ECB
int des_ECB_encrypt_string(const char *str, char *dst, uint64_t key);
void des_ECB_decrypt_string(const char *cipher, char *dst, int length, uint64_t key);

void des_ECB_encrypt_file(const char *src, const char *dst, uint64_t key);
void des_ECB_decrypt_file(const char *cipher, const char *dst, uint64_t key);

// CBC
int des_CBC_encrypt_string(const char *str, char *dst, uint64_t key);
void des_CBC_decrypt_string(const char *cipher, char *dst, int length, uint64_t key);

void des_CBC_encrypt_file(const char *src, const char *dst, uint64_t key);
void des_CBC_decrypt_file(const char *cipher, const char *dst, uint64_t key);

// PCBC
int des_PCBC_encrypt_string(const char *str, char *dst, uint64_t key);
void des_PCBC_decrypt_string(const char *cipher, char *dst, int length, uint64_t key);

void des_PCBC_encrypt_file(const char *src, const char *dst, uint64_t key);
void des_PCBC_decrypt_file(const char *cipher, const char *dst, uint64_t key);

// CFB
int des_CFB_encrypt_string(const char *str, char *dst, uint64_t key);
void des_CFB_decrypt_string(const char *cipher, char *dst, int length, uint64_t key);

void des_CFB_encrypt_file(const char *src, const char *dst, uint64_t key);
void des_CFB_decrypt_file(const char *cipher, const char *dst, uint64_t key);

// OFB
int des_OFB_encrypt_string(const char *str, char *dst, uint64_t key);
void des_OFB_decrypt_string(const char *cipher, char *dst, int length, uint64_t key);

void des_OFB_encrypt_file(const char *src, const char *dst, uint64_t key);
void des_OFB_decrypt_file(const char *cipher, const char *dst, uint64_t key);

// CTR
int des_CTR_encrypt_string(const char *str, char *dst, uint64_t key);
void des_CTR_decrypt_string(const char *cipher, char *dst, int length, uint64_t key);

void des_CTR_encrypt_file(const char *src, const char *dst, uint64_t key);
void des_CTR_decrypt_file(const char *cipher, const char *dst, uint64_t key);
.
---------- pkcs7.h ----------
#pragma once

#include <stdint.h>
#include <string.h>

uint64_t add_padding(uint8_t tailingBytes[],int numOfBytes);
int get_padding_len(uint64_t block);