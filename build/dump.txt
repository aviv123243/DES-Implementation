===== DUMP: All .c source files =====

---------- main.c ----------
#include <stdlib.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>

#include "modes/modes.h"
#include "key_iv/key_iv.h"

#include <inttypes.h>

void testFileEncryption(uint64_t key,uint64_t iv);
void testStringEncryption(uint64_t key);


int main() {

    // uint64_t key = 0x133457799BBCDFF1;

    testFileEncryption(generate_random_key(),generate_random_iv());
    

    return 0;
}

void testFileEncryption(uint64_t key,uint64_t iv)
{
    printf("encrypting...\n");

    des_PCBC_encrypt_file("../test/plaintext.txt","../test/ciphertext.txt",iv,key);

    printf("decrypting...\n");

    des_PCBC_decrypt_file("../test/ciphertext.txt","../test/decoded.txt",iv,key);
}

void testStringEncryption(uint64_t key)
{
    const char *plaintext = "Hello DES!";
    char encrypted[64] = {0};
    char decrypted[64] = {0};

    printf("Plaintext: %s\n", plaintext);

    int newLen = des_ECB_encrypt_string(plaintext, encrypted, key);

    printf("encrypted: ");

    fwrite(encrypted,sizeof(char),newLen,stdout);

    des_ECB_decrypt_string(encrypted, decrypted, newLen, key);

    printf("\nDecrypted: %s\n", decrypted);
}.
---------- f.c ----------
#include <stdint.h>
#include <stdlib.h>
#include "f.h"
extern const int E[48];
extern const char S[8][4][16];
extern const int P[32];

uint64_t expand(uint32_t right);
uint32_t keyed_substitution(uint64_t right);
uint32_t PBox_transposition(uint32_t right);

uint32_t F(uint32_t right,uint64_t subKey)
{
    // implamenting the mangler function

    uint32_t res;

    uint64_t expandedRight = expand(right);

    expandedRight ^= subKey;

    res = keyed_substitution(expandedRight);

    res = PBox_transposition(res);

    return res;
}

uint64_t expand(uint32_t right)
{
    uint64_t result = 0;

    for (int i = 0; i < 48; i++) {
        int bit_index = E[i] - 1; 
        int bit = (right >> (31 - bit_index)) & 1; 
        result |= ((uint64_t)bit << (47 - i)); 
    }

    return result;
}

uint32_t keyed_substitution(uint64_t right)
{
    uint32_t res = 0;

    for (int i = 0; i < 8; i++) {
        // Extract the i-th 6-bit chunk 
        // with the mask 0011 1111 (last 6 bits)
        uint8_t chunk = (right >> (42 - 6 * i)) & 0x3F;

        // Compute row and column
        int row = ((chunk & 0x20) >> 4) | (chunk & 0x01);  // bits 6 and 1
        int col = (chunk >> 1) & 0x0F;                     // bits 2â€“5

        // Lookup S-box output (4 bits)
        uint8_t s_out = S[i][row][col] & 0x0F;

        // Place into result (MSB-first)
        res |= s_out << (28 - 4 * i);
    }

    return res;
}

uint32_t PBox_transposition(uint32_t right)
{
    uint32_t res = 0;
    
    for (int i = 0; i < 32; i++)
    {
        //fetch the next bit according to the P box
        int bit = (right >> (32 - P[i])) & 1;

        //place it
        res |= (bit << (31 - i));
    }

    return res;
    
}.
---------- des.c ----------
#include <stdlib.h>
#include <stdint.h>
#include "des.h"
#include "../f_function/f.h"
#include "../subkey_genaration/subKeyGen.h"

uint64_t permute(uint64_t block, const int table[64])
{
    uint64_t res = 0;

    for (int i = 0; i < 64; i++)
    {
        int bit = (block >> (64 - table[i])) & 1;
        res |= ((uint64_t)bit << (63 - i));
    }

    return res;
}

uint64_t des_block(uint64_t block, uint64_t subkeys[], Operation operation)
{
    block = permute(block, IP);

    uint32_t R = block & L64_MASK;
    uint32_t L = (block & H64_MASK) >> 32;
    uint32_t RCopy;
    int subKeyIndex;

    for (int i = 0; i < 16; i++)
    {
        subKeyIndex = (operation == ENCRYPT) ? i : 15 - i;

        RCopy = R;

        R = F(R, subkeys[subKeyIndex]) ^ L;

        L = RCopy;
    }

    block = ((uint64_t)R << 32) | L;

    return permute(block, PI);
}
.
---------- subKeyGen.c ----------
#include <stdint.h>
#include <stdlib.h>
#include "subKeyGen.h"

extern const int PC1[56];
extern const int PC2[48];
extern const int LEFT_SHIFTS[NUM_OF_SUBKEYS];

uint64_t permuted_choice2(uint32_t Ci, uint32_t Di);

typedef struct subKeyGenType
{
    uint32_t Ci; // 28-bit
    uint32_t Di; // 28-bit
    int i;
} subKeyGen;

uint32_t circular_left_shift_28(uint32_t chunk, int nshifts)
{
    chunk &= 0x0FFFFFFF;
    return ((chunk << nshifts) | (chunk >> (28 - nshifts))) & 0x0FFFFFFF;
}

void permuted_choice1(uint64_t key, uint32_t *Ci, uint32_t *Di)
{
    *Ci = 0;
    *Di = 0;

    for (int i = 0; i < 28; i++) {
        int bit = (key >> (64 - PC1[i])) & 1;
        *Ci |= (bit << (27 - i));
    }

    for (int i = 0; i < 28; i++) {
        int bit = (key >> (64 - PC1[i + 28])) & 1;
        *Di |= (bit << (27 - i));
    }
}

uint64_t permuted_choice2(uint32_t Ci, uint32_t Di)
{
    uint64_t CD = (((uint64_t)Ci) << 28) | (Di & 0x0FFFFFFF); // combine into 56-bit
    uint64_t subkey = 0;

    for (int i = 0; i < 48; i++) {
        int bit = (CD >> (56 - PC2[i])) & 1;
        subkey |= ((uint64_t)bit << (47 - i));
    }

    return subkey;
}

void keyGen_init(subKeyGen *skg, uint64_t key)
{
    permuted_choice1(key, &skg->Ci, &skg->Di);  

    skg->i = 0;
}

uint64_t keyGen_next(subKeyGen *skg) {
    //shift the two halfs
    skg->Ci = circular_left_shift_28(skg->Ci,LEFT_SHIFTS[skg->i]);
    skg->Di = circular_left_shift_28(skg->Di,LEFT_SHIFTS[skg->i]);

    //incrament i
    skg->i++;

    //return the permuted Choice 2
    return permuted_choice2(skg->Ci,skg->Di)   ;
}

void generate_sub_keys(uint64_t key, uint64_t subkeys[16])
{
    subKeyGen skg;
    keyGen_init(&skg, key);

    for (int i = 0; i < NUM_OF_SUBKEYS; i++)
    {
        subkeys[i] = keyGen_next(&skg);  
    }
}

.
---------- key_iv.c ----------
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>

#include "key_iv.h"

uint64_t generate_random_key()
{
    srand(time(NULL) ^ clock());

    uint64_t key = 0;
    uint8_t currByte;

    for (int i = 0; i < KEY_SIZE_BYTES; i++)
    {
        // first 7 random bits
        currByte = rand() & LAST_7_BITS_MASK;

        // calculating the parity
        uint8_t parity = __builtin_parity(currByte) ? 0 : 1;

        // appending the parity
        currByte = (currByte << 1) | parity;

        // appending the byte
        key |= ((uint64_t)currByte << i * 8);
    }

    return key;
}

uint64_t generate_random_iv()
{
    srand(time(NULL) ^ clock());

    uint64_t iv = 0;

    for (int i = 0; i < IV_SIZE_BYTES; i++)
    {
        //genarating the next byte
        uint8_t randByte = rand() & LAST_BYTE_MASK;

        //appending it to the iv
        iv |= ((uint64_t)randByte << i*8);
    }

    return iv;
}
.
---------- CBC.c ----------
#include "modes.h"

void des_CBC_encrypt_file(const char *src, const char *dst,uint64_t iv, uint64_t key)
{
    uint64_t subKeys[16];
    generate_sub_keys(key, subKeys);

    FILE *srcP = fopen(src, "rb");
    FILE *dstP = fopen(dst, "wb");

    if (!srcP || !dstP) return;

    uint8_t blockBuffer[8];
    size_t bytesRead;

    uint64_t prevBlock = iv;

    while ((bytesRead = fread(blockBuffer, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, srcP)) == SIZE_OF_BLOCK_BYTES)
    {
        uint64_t block;
        memcpy(&block, blockBuffer, SIZE_OF_BLOCK_BYTES);

        //xor-ing with the previus block (or iv for the first round)
        //as instructed for the CBC mode
        block ^= prevBlock;

        uint64_t encrypted = des_block(block, subKeys, ENCRYPT);

        prevBlock = encrypted;

        fwrite(&encrypted, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, dstP);
    }

    // Pad the final block
    uint64_t lastBlock = add_padding(blockBuffer, bytesRead);

    //xor it with prev
    lastBlock ^= prevBlock;

    uint64_t encrypted = des_block(lastBlock, subKeys, ENCRYPT);
    fwrite(&encrypted, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, dstP);
    

    fclose(srcP);
    fclose(dstP);
}

void des_CBC_decrypt_file(const char *cipher, const char *dst,uint64_t iv, uint64_t key)
{
    uint64_t subKeys[16];
    generate_sub_keys(key, subKeys);

    FILE *cipherP = fopen(cipher, "rb");
    FILE *dstP = fopen(dst, "wb");

    if (!cipherP || !dstP)
        return;

    uint64_t currentBlock, nextBlock;
    uint64_t prevBlock = iv;
    size_t bytesRead;
    
    bytesRead = fread(&currentBlock, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, cipherP);

    while (bytesRead == SIZE_OF_BLOCK_BYTES)
    {
        bytesRead = fread(&nextBlock, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, cipherP);

        uint64_t decrypted = des_block(currentBlock, subKeys, DECRYPT);

        decrypted ^= prevBlock;

        prevBlock = currentBlock;

        if (bytesRead < SIZE_OF_BLOCK_BYTES)
        {
            // This is the last block, strip padding
            int padLen = get_padding_len(decrypted);
            fwrite(&decrypted, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES - padLen, dstP);
        }
        else
        {
            fwrite(&decrypted, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, dstP);
        }

        currentBlock = nextBlock;
    }

    fclose(cipherP);
    fclose(dstP);
}.
---------- ECB.c ----------
#include "modes.h"

// encrypting a string in ECB mode
// returning the length of the ciphertext
int des_ECB_encrypt_string(const char *str, char *dst, uint64_t key)
{
    uint64_t subKeys[16];
    generate_sub_keys(key, subKeys);

    int len = strlen(str);
    int i = 0;

    uint64_t encrypted;

    int lenOfPrefectBlocks = (len / 8) * 8;

    while (i < lenOfPrefectBlocks)
    {
        uint64_t block;

        memcpy(&block, str + i, 8);

        encrypted = des_block(block, subKeys, ENCRYPT);

        memcpy(dst + i, &encrypted, SIZE_OF_BLOCK_BYTES);

        i += SIZE_OF_BLOCK_BYTES;
    }

    uint8_t blockBuffer[8] = {0};

    int numOfTailingBytes = len - lenOfPrefectBlocks;

    // load the tailing bytes into a buffer
    memcpy(blockBuffer, str + i, numOfTailingBytes);

    // create the last block (with the padding)
    uint64_t lastBlock = add_padding(blockBuffer, numOfTailingBytes);

    // encrypt te last block
    encrypted = des_block(lastBlock, subKeys, ENCRYPT);

    // add it to the ciphertext
    memcpy(dst + i, &encrypted, SIZE_OF_BLOCK_BYTES);

    // return the length
    return i + SIZE_OF_BLOCK_BYTES;
}

void des_ECB_decrypt_string(const char *cipher, char *dst, int length, uint64_t key)
{
    uint64_t subKeys[16];

    generate_sub_keys(key, subKeys);

    int dstIndex = 0;

    for (int i = 0; i < length; i += 8)
    {
        uint64_t block;

        memcpy(&block, cipher + i, 8);

        uint64_t decrypted = des_block(block, subKeys, DECRYPT);

        memcpy(dst + dstIndex, &decrypted, 8);

        dstIndex += 8;
    }

    uint64_t lastBlock;
    memcpy(&lastBlock, dst + dstIndex - SIZE_OF_BLOCK_BYTES, SIZE_OF_BLOCK_BYTES);

    // getting the actual size of the last block (without padding)
    int padLen = get_padding_len(lastBlock);

    // putting a null terminator at the end of the original plaintext
    int actualLength = dstIndex - padLen;
    dst[actualLength] = '\0';
}

void des_ECB_encrypt_file(const char *src, const char *dst, uint64_t key)
{
    uint64_t subKeys[16];
    generate_sub_keys(key, subKeys);

    FILE *srcP = fopen(src, "rb");
    FILE *dstP = fopen(dst, "wb");

    if (!srcP || !dstP)
        return;

    uint8_t blockBuffer[8];
    size_t bytesRead;

    while ((bytesRead = fread(blockBuffer, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, srcP)) == SIZE_OF_BLOCK_BYTES)
    {
        uint64_t block;
        memcpy(&block, blockBuffer, SIZE_OF_BLOCK_BYTES);

        uint64_t encrypted = des_block(block, subKeys, ENCRYPT);
        fwrite(&encrypted, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, dstP);
    }

    // Pad the final block
    uint64_t lastBlock = add_padding(blockBuffer, bytesRead);
    uint64_t encrypted = des_block(lastBlock, subKeys, ENCRYPT);
    fwrite(&encrypted, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, dstP);

    fclose(srcP);
    fclose(dstP);
}

void des_ECB_decrypt_file(const char *cipher, const char *dst, uint64_t key)
{
    uint64_t subKeys[16];
    generate_sub_keys(key, subKeys);

    FILE *cipherP = fopen(cipher, "rb");
    FILE *dstP = fopen(dst, "wb");

    if (!cipherP || !dstP)
        return;

    uint64_t currentBlock, nextBlock;
    size_t bytesRead;

    // Prime the loop
    bytesRead = fread(&currentBlock, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, cipherP);

    while (bytesRead == SIZE_OF_BLOCK_BYTES)
    {
        bytesRead = fread(&nextBlock, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, cipherP);

        uint64_t decrypted = des_block(currentBlock, subKeys, DECRYPT);

        if (bytesRead < SIZE_OF_BLOCK_BYTES)
        {
            // This is the last block, strip padding
            int padLen = get_padding_len(decrypted);
            fwrite(&decrypted, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES - padLen, dstP);
        }
        else
        {
            fwrite(&decrypted, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, dstP);
        }

        currentBlock = nextBlock;
    }

    fclose(cipherP);
    fclose(dstP);
}
.
---------- PCBC.c ----------
#include "modes.h"

void des_PCBC_encrypt_file(const char *src, const char *dst,uint64_t iv, uint64_t key)
{
    uint64_t subKeys[16];
    generate_sub_keys(key, subKeys);

    FILE *srcP = fopen(src, "rb");
    FILE *dstP = fopen(dst, "wb");

    if (!srcP || !dstP) return;

    uint8_t blockBuffer[8];
    size_t bytesRead;

    uint64_t prevBlock = iv;

    while ((bytesRead = fread(blockBuffer, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, srcP)) == SIZE_OF_BLOCK_BYTES)
    {
        uint64_t block;
        memcpy(&block, blockBuffer, SIZE_OF_BLOCK_BYTES);

        //xor-ing with the previus block (or iv for the first round)
        //as instructed for the CBC mode
        block ^= prevBlock;

        uint64_t encrypted = des_block(block, subKeys, ENCRYPT);

        prevBlock = encrypted ^ block;

        fwrite(&encrypted, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, dstP);
    }

    // Pad the final block
    uint64_t lastBlock = add_padding(blockBuffer, bytesRead);

    //xor it with prev
    lastBlock ^= prevBlock;

    uint64_t encrypted = des_block(lastBlock, subKeys, ENCRYPT);
    fwrite(&encrypted, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, dstP);
    

    fclose(srcP);
    fclose(dstP);
}

void des_PCBC_decrypt_file(const char *cipher, const char *dst,uint64_t iv, uint64_t key)
{
    uint64_t subKeys[16];
    generate_sub_keys(key, subKeys);

    FILE *cipherP = fopen(cipher, "rb");
    FILE *dstP = fopen(dst, "wb");

    if (!cipherP || !dstP)
        return;

    uint64_t currentBlock, nextBlock;
    uint64_t prevBlock = iv;
    size_t bytesRead;
    
    bytesRead = fread(&currentBlock, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, cipherP);

    while (bytesRead == SIZE_OF_BLOCK_BYTES)
    {
        bytesRead = fread(&nextBlock, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, cipherP);

        uint64_t decrypted = des_block(currentBlock, subKeys, DECRYPT);

        decrypted ^= prevBlock;

        prevBlock = currentBlock ^ decrypted;

        if (bytesRead < SIZE_OF_BLOCK_BYTES)
        {
            // This is the last block, strip padding
            int padLen = get_padding_len(decrypted);
            fwrite(&decrypted, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES - padLen, dstP);
        }
        else
        {
            fwrite(&decrypted, sizeof(uint8_t), SIZE_OF_BLOCK_BYTES, dstP);
        }

        currentBlock = nextBlock;
    }

    fclose(cipherP);
    fclose(dstP);
}.
---------- pkcs7.c ----------
#include <stdint.h>
#include "../modes/modes.h"

uint64_t add_padding(uint8_t tailingBytes[],int numOfBytes)
{
    uint8_t bytes[8] = {0};
    uint64_t res;

    memcpy(bytes, tailingBytes, numOfBytes);  

    uint8_t padValue = SIZE_OF_BLOCK_BYTES - numOfBytes;

    for (int i = numOfBytes; i < SIZE_OF_BLOCK_BYTES; i++) {
        bytes[i] = padValue;  
    }

    memcpy(&res, bytes, SIZE_OF_BLOCK_BYTES);

    return res;
}

int get_padding_len(uint64_t block) {
    uint8_t bytes[8];

    memcpy(bytes,&block,SIZE_OF_BLOCK_BYTES);

    return bytes[SIZE_OF_BLOCK_BYTES - 1];  
}
===== DUMP: All .h header files =====

---------- f.h ----------
#pragma once

#include <stdint.h>

static const int E[48] = {
    32, 1, 2, 3, 4, 5,
    4, 5, 6, 7, 8, 9,
    8, 9, 10, 11, 12, 13,
    12, 13, 14, 15, 16, 17,
    16, 17, 18, 19, 20, 21,
    20, 21, 22, 23, 24, 25,
    24, 25, 26, 27, 28, 29,
    28, 29, 30, 31, 32, 1};

static const int P[32] = {
    16, 7, 20, 21,
    29, 12, 28, 17,
    1, 15, 23, 26,
    5, 18, 31, 10,
    2, 8, 24, 14,
    32, 27, 3, 9,
    19, 13, 30, 6,
    22, 11, 4, 25
};

//[box][row][column]
static const char S[8][4][16] = {
    {   // S1
        {14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7},
        { 0,15,  7, 4,14,  2,13, 1,10,  6,12,11, 9, 5, 3, 8},
        { 4, 1, 14, 8,13,  6, 2,11,15, 12, 9, 7, 3,10, 5, 0},
        {15,12,  8, 2, 4,  9, 1, 7, 5, 11, 3,14,10, 0, 6,13}
    },
    {   // S2
        {15, 1,  8,14, 6,11, 3, 4, 9, 7, 2,13,12, 0, 5,10},
        { 3,13,  4, 7,15, 2, 8,14,12, 0, 1,10, 6, 9,11, 5},
        { 0,14,  7,11,10, 4,13, 1, 5, 8,12, 6, 9, 3, 2,15},
        {13, 8, 10, 1, 3,15, 4, 2,11, 6, 7,12, 0, 5,14, 9}
    },
    {   // S3
        {10, 0, 9,14, 6, 3,15, 5, 1,13,12, 7,11, 4, 2, 8},
        {13, 7, 0, 9, 3, 4, 6,10, 2, 8, 5,14,12,11,15, 1},
        {13, 6, 4, 9, 8,15, 3, 0,11, 1, 2,12, 5,10,14, 7},
        { 1,10,13, 0, 6, 9, 8, 7, 4,15,14, 3,11, 5, 2,12}
    },
    {   // S4
        { 7,13,14, 3, 0, 6, 9,10, 1, 2, 8, 5,11,12, 4,15},
        {13, 8,11, 5, 6,15, 0, 3, 4, 7, 2,12, 1,10,14, 9},
        {10, 6, 9, 0,12,11, 7,13,15, 1, 3,14, 5, 2, 8, 4},
        { 3,15, 0, 6,10, 1,13, 8, 9, 4, 5,11,12, 7, 2,14}
    },
    {   // S5
        { 2,12, 4, 1, 7,10,11, 6, 8, 5, 3,15,13, 0,14, 9},
        {14,11, 2,12, 4, 7,13, 1, 5, 0,15,10, 3, 9, 8, 6},
        { 4, 2, 1,11,10,13, 7, 8,15, 9,12, 5, 6, 3, 0,14},
        {11, 8,12, 7, 1,14, 2,13, 6,15, 0, 9,10, 4, 5, 3}
    },
    {   // S6
        {12, 1,10,15, 9, 2, 6, 8, 0,13, 3, 4,14, 7, 5,11},
        {10,15, 4, 2, 7,12, 9, 5, 6, 1,13,14, 0,11, 3, 8},
        { 9,14,15, 5, 2, 8,12, 3, 7, 0, 4,10, 1,13,11, 6},
        { 4, 3, 2,12, 9, 5,15,10,11,14, 1, 7, 6, 0, 8,13}
    },
    {   // S7
        { 4,11, 2,14,15, 0, 8,13, 3,12, 9, 7, 5,10, 6, 1},
        {13, 0,11, 7, 4, 9, 1,10,14, 3, 5,12, 2,15, 8, 6},
        { 1, 4,11,13,12, 3, 7,14,10,15, 6, 8, 0, 5, 9, 2},
        { 6,11,13, 8, 1, 4,10, 7, 9, 5, 0,15,14, 2, 3,12}
    },
    {   // S8
        {13, 2, 8, 4, 6,15,11, 1,10, 9, 3,14, 5, 0,12, 7},
        { 1,15,13, 8,10, 3, 7, 4,12, 5, 6,11, 0,14, 9, 2},
        { 7,11, 4, 1, 9,12,14, 2, 0, 6,10,13,15, 3, 5, 8},
        { 2, 1,14, 7, 4,10, 8,13,15,12, 9, 0, 3, 5, 6,11}
    }
};


uint32_t F(uint32_t right,uint64_t subKey);.
---------- des.h ----------
#pragma once

#define LB32_MASK 0x00000001
#define LB64_MASK 0x0000000000000001
#define L64_MASK 0x00000000ffffffff
#define H64_MASK 0xffffffff00000000

static const int IP[] = {
    58, 50, 42, 34, 26, 18, 10,  2, 
    60, 52, 44, 36, 28, 20, 12,  4, 
    62, 54, 46, 38, 30, 22, 14,  6, 
    64, 56, 48, 40, 32, 24, 16,  8, 
    57, 49, 41, 33, 25, 17,  9,  1, 
    59, 51, 43, 35, 27, 19, 11,  3, 
    61, 53, 45, 37, 29, 21, 13,  5, 
    63, 55, 47, 39, 31, 23, 15,  7
};

static const int PI[] = {
    40,  8, 48, 16, 56, 24, 64, 32, 
    39,  7, 47, 15, 55, 23, 63, 31, 
    38,  6, 46, 14, 54, 22, 62, 30, 
    37,  5, 45, 13, 53, 21, 61, 29, 
    36,  4, 44, 12, 52, 20, 60, 28, 
    35,  3, 43, 11, 51, 19, 59, 27, 
    34,  2, 42, 10, 50, 18, 58, 26, 
    33,  1, 41,  9, 49, 17, 57, 25
};

typedef enum
{
    ENCRYPT,
    DECRYPT
} Operation;

// typedef enum CipherMode
// {
//     ECB,
//     CBC,
//     CFB,
//     OFB,
//     CTR
// };

uint64_t des_block(uint64_t block, uint64_t subkeys[], Operation operation);
.
---------- subKeyGen.h ----------
#pragma once

#include <stdint.h>

#define NUM_OF_SUBKEYS 16

// PC-1: 64-bit input key â†’ 56-bit output (C0 and D0)
static const int PC1[56] = {
    57,49,41,33,25,17,9,
    1,58,50,42,34,26,18,
    10,2,59,51,43,35,27,
    19,11,3,60,52,44,36,
    63,55,47,39,31,23,15,
    7,62,54,46,38,30,22,
    14,6,61,53,45,37,29,
    21,13,5,28,20,12,4
};

// PC-2: 56-bit C||D â†’ 48-bit subkey
static const int PC2[48] = {
    14,17,11,24,1,5,
    3,28,15,6,21,10,
    23,19,12,4,26,8,
    16,7,27,20,13,2,
    41,52,31,37,47,55,
    30,40,51,45,33,48,
    44,49,39,56,34,53,
    46,42,50,36,29,32
};

static const int LEFT_SHIFTS[16] = {
    1, 1, 2, 2,
    2, 2, 2, 2,
    1, 2, 2, 2,
    2, 2, 2, 1
};

void generate_sub_keys(uint64_t key,uint64_t subkeys[16]);.
---------- key_iv.h ----------
#pragma once
#include <stdint.h>

#define KEY_SIZE_BYTES 8
#define IV_SIZE_BYTES 8
#define LAST_7_BITS_MASK 0x7f
#define LAST_BYTE_MASK 0xf

uint64_t generate_random_key();
uint64_t generate_random_iv();.
---------- modes.h ----------
#pragma once

#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <stdio.h>

#include "../des_block/main_encryption/des.h"
#include "../des_block/subkey_genaration/subKeyGen.h"
#include "../pkcs7_padding/pkcs7.h"

#include "inttypes.h"

#define SIZE_OF_BLOCK_BYTES 8

//EBC
int des_ECB_encrypt_string(const char *str, char *dst, uint64_t key);
void des_ECB_decrypt_string(const char *cipher, char *dst, int length, uint64_t key);

void des_ECB_encrypt_file(const char *src, const char * dst, uint64_t key);
void des_ECB_decrypt_file(const char *cipher, const char * dst, uint64_t key);

//CBC
void des_CBC_encrypt_file(const char *src, const char *dst,uint64_t iv, uint64_t key);
void des_CBC_decrypt_file(const char *cipher, const char *dst,uint64_t iv, uint64_t key);

//PCBC 
void des_PCBC_encrypt_file(const char *src, const char *dst,uint64_t iv, uint64_t key);
void des_PCBC_decrypt_file(const char *cipher, const char *dst,uint64_t iv, uint64_t key);



.
---------- pkcs7.h ----------
#pragma once

#include <stdint.h>
#include <string.h>

uint64_t add_padding(uint8_t tailingBytes[],int numOfBytes);
int get_padding_len(uint64_t block);